-- vim:syn=haskell

-- SK-calculus.
define "S" (\x y z -> x z (y z))
define "K" (\x _ -> x)
define "I" (\x -> x)

-- Curry's BCKW system.
define "B" (\x y z -> x (y z))
define "C" (\x y z -> x z y)
define "W" (\x y -> x y y)

-- Curry's Y combinator.
define "Y" (\f -> (\x -> f (x x)) (\x -> f (x x)))

-- Booleans.
define "T" (\x y -> x)
define "F" (\x y -> y)

-- Boolean logic.
define "and" (\m n -> m n m)
define "or" (\m n -> m m n)
define "not" (\m -> m F T)
define "xor" (\m n -> m (n F T) n)

-- Church pairs.
define "pair" (\x y z -> z x y)
define "fst" (\p -> p \x y -> x)
define "snd" (\p -> p \x y -> y)

-- Church numerals.
define "unchurch" (\n -> memoize (n (scalar+ 1) 0))
define "+" (\m n f x -> memoize (m f (n f x)))
define "*" (\m n f -> memoize (n (m f)))
define "**" (\m n -> memoize (n m))
define "pred" (\n f x -> memoize (n (\g h -> h (g f)) (\_ -> x) (\u -> u)))
define "succ" (\n f x -> memoize (f (n f x)))
define "zero?" (\n -> memoize (n (\_ -> F) T))
define "=" (\x y -> memoize (scalar= (unchurch x) (unchurch y)))
define "<" (\x y -> memoize (scalar< (unchurch x) (unchurch y)))
define "fact" (\n -> Y (\f -> \n -> memoize (zero? n $1 (* n (f (pred n))))) n)

-- Lists.
define "nil" (memoize (pair T error))
define "nil?" (\x -> memoize (fst x))
define "cons" (\h t -> pair F (pair h t))
define "car" (\z -> fst (snd z))
define "cdr" (\z -> snd (snd z))

-- List-processing.
define "foldl" (Y \f -> \b z l -> nil? l z (f b (b z (car l)) (cdr l)))
define "foldr" (Y \f -> \b z l -> nil? l z (b (car l) (f b z (cdr l))))
define "apply" (foldl I I)
define "append" (Y \f -> \l m -> nil? l m (cons (car l) (f (cdr l) m)))
define "map" (Y \f -> \g l -> nil? l nil (cons (g (car l)) (f g (cdr l))))
define "reverse" (foldl (\x y -> cons y x) nil)
define "show-list" (\l -> string+ (string+ "[" (nil? l "" (foldl (\x y -> string+ (string+ x ", ") (show y)) (show (car l)) (cdr l)))) "]")
define "print-list" (\l -> print (show-list l) print "\n")

-- Function composition.
define "." (B)
define "compose" (foldl . I)

-- List creation.
define "repeat" (\n x -> n (cons x) nil)
define "times" (\n f -> compose (repeat n))
define "range" (Y \f -> \x p g -> (cons x (not (p x) nil (f (g x) p g))))
define "up" (\x -> range x (\y -> T))
define "down" (\x -> range x (\y -> not (zero? y)) pred)
define "from" (\x -> up x succ)
define "upto" (\x y -> range x (\z -> not (= y z)) succ)
define ".." (upto)
