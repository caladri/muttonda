-- vim:syn=haskell

-- SK-calculus.
define "S" (\x y z -> x z (y z))
define "K" (\x _ -> x)
define "I" (\x -> x)

-- Curry's BCKW system.
define "B" (\x y z -> x (y z))
define "C" (\x y z -> x z y)
define "W" (\x y -> x y y)

-- Curry's Y combinator.
define "Y" (\f -> (\x -> f (x x)) (\x -> f (x x)))

-- Booleans.
define "T" (\x _ -> x)
define "F" (\_ y -> y)

-- Boolean logic.
define "and" (\m n -> m n m)
define "or" (\m n -> m m n)
define "not" (\m -> m F T)
define "xor" (\m n -> m (n F T) n)

-- Church pairs.
define "pair" (\x y z -> z x y)
define "fst" (\p -> p \x y -> x)
define "snd" (\p -> p \x y -> y)
define "apply-pair" (\f p -> p \x y -> (f x), (f y))
define "show-pair'" (\p -> ("(" `string+` (((fst p) `string+` ", ") `string+` (snd p))) `string+` ")")
define "show-pair" (\p -> show-pair' (apply-pair show p))

-- Church numerals.
define "unchurch" (\n -> memoize (n (scalar+ 1) 0))
define "+" (\m n f x -> memoize (m f (n f x)))
define "*" (\m n -> B n m)
define "**" (\m n -> memoize (n m))
define "pred" (\n f x -> memoize (n (\g h -> h (g f)) (\_ -> x) (\u -> u)))
define "succ" (\n f x -> memoize (f (n f x)))
define "zero?" (\n -> memoize (n (\_ -> F) T))
define "=" (\x y -> memoize (scalar= (unchurch x) (unchurch y)))
define "<" (\x y -> memoize (scalar< (unchurch x) (unchurch y)))
define "fact" (Y \f -> \n -> memoize (zero? n $1 (* n (f (pred n)))))

-- Lists.
define "nil" (memoize (T, error))
define "nil?" (\x -> memoize (fst x))
define "cons" (\h t -> F, (h, t))
define "car" (\z -> fst (snd z))
define "cdr" (\z -> snd (snd z))

-- List-processing.
define "foldl" (Y \f -> \b z l -> nil? l z (f b (b z (car l)) (cdr l)))
define "foldr" (Y \f -> \b z l -> nil? l z (b (car l) (f b z (cdr l))))
define "apply" (foldl I I)
define "append" (Y \f -> \l m -> nil? l m (cons (car l) (f (cdr l) m)))
define "map" (Y \f -> \g l -> nil? l nil (cons (g (car l)) (f g (cdr l))))
define "reverse" (foldl (\x y -> cons y x) nil)
define "show-list" (\l -> ("[" `string+` (nil? l "" (foldl (\x y -> (x `string+` ", ") `string+` (show y)) (show (car l)) (cdr l)))) `string+` "]")
define "print-list" (\l -> print (show-list l) print "\n")
define "split-list" (Y (\f m -> \p l -> nil? l (m, nil) (p (car l) (m, l) (f (append m (cons (car l) nil)) p (cdr l)))) nil)

-- Function composition.
define "." (B)
define "compose" (foldl . I)

-- List creation.
define "repeat" (\n x -> n (cons x) nil)
define "times" (\n f -> compose (repeat n))
define "range" (Y \f -> \x p g -> (cons x (not (p x) nil (f (g x) p g))))
define "up" (\x -> range x (\y -> T))
define "from" (\x -> up x succ)
define "upto" (\x y -> range x (\z -> not (= y z)) succ)
define "down" (\x -> reverse (upto $0 x))
define ".." (upto)

-- String processing.
define "String" string!
define "show-String" (foldl string+ "")
define "break-String" (Y (\f t -> \p s -> nil? s (nil? (String t) nil (cons t nil)) (p (car s) (cons (string+ t (car s)) (f "" p (cdr s))) (f (string+ t (car s)) p (cdr s)))) "")
define "split-String" (Y (\f t -> \p s -> nil? s (nil? (String t) nil (cons t nil)) (p (car s) (cons t (f "" p (cdr s))) (f (string+ t (car s)) p (cdr s)))) "")
define "tokenize-String" (Y (\f t -> \p s -> nil? s (nil? (String t) nil (cons t nil)) (p (car s) (cons t (cons (car s) (f "" p (cdr s)))) (f (string+ t (car s)) p (cdr s)))) "")
-- TODO: Add a variant that sends first and butfirst to the predicate, which returns whether there is a token, the token, the remainder, etc.
